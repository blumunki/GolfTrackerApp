@page "/admin/datamigration"
@attribute [Authorize(Roles = "Admin")] // Only Admins can access this page
@inject NavigationManager NavigationManager
@inject IServiceScopeFactory ServiceScopeFactory // For resolving services in a long-running task

@using System.IO
@using System.Globalization
@using CsvHelper
@using CsvHelper.Configuration
@using GolfTrackerApp.Web.Data
@using GolfTrackerApp.Web.Models
@using GolfTrackerApp.Web.Services
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Identity
@using Microsoft.EntityFrameworkCore

@rendermode InteractiveServer

<PageTitle>Data Migration</PageTitle>

<h1>Data Migration Utility</h1>

<p><strong>Important:</strong> Upload files in the specified order. Ensure CSV files are UTF-8 encoded.</p>

<div class="migration-section mb-4">
    <h4>1. Import Golf Clubs</h4>
    <p>CSV Format: Name, AddressLine1, AddressLine2, City, CountyOrRegion, Postcode, Country, Website</p>
    <InputFile OnChange="HandleGolfClubsUpload" accept=".csv" />
    <button class="btn btn-primary mt-2" @onclick="ProcessGolfClubs" disabled="@(golfClubsFile == null || isProcessingGolfClubs)">
        @if (isProcessingGolfClubs) { <span>Processing...</span> } else { <span>Import Golf Clubs</span> }
    </button>
    @if (!string.IsNullOrEmpty(golfClubsImportLog))
    {
        <pre class="log-output">@golfClubsImportLog</pre>
    }
</div>

@* --- Import Golf Courses --- *@
<div class="migration-section mb-4">
    <h4>2. Import Golf Courses</h4>
    <p>CSV Format: ClubName (must match an already imported club's name), CourseName, DefaultPar, NumberOfHoles</p>
    <InputFile OnChange="HandleGolfCoursesUpload" accept=".csv" />
    <button class="btn btn-primary mt-2" @onclick="ProcessGolfCourses" disabled="@(golfCoursesFile == null || isProcessingGolfCourses || isProcessingGolfClubs)">
        @if (isProcessingGolfCourses) { <span>Processing...</span> } else { <span>Import Golf Courses</span> }
    </button>
    @if (!string.IsNullOrEmpty(golfCoursesImportLog))
    {
        <pre class="log-output">@golfCoursesImportLog</pre>
    }
</div>


@* --- Import Players --- *@
<div class="migration-section mb-4">
    <h4>3. Import Players</h4>
    <p>CSV Format: FirstName, LastName, Email (optional; if provided, attempts to link/create system user), Handicap (optional)</p>
    <InputFile OnChange="HandlePlayersUpload" accept=".csv" />
    <button class="btn btn-primary mt-2" @onclick="ProcessPlayers" disabled="@(playersFile == null || isProcessingPlayers || isProcessingGolfClubs || isProcessingGolfCourses)">
        @if (isProcessingPlayers) { <span>Processing...</span> } else { <span>Import Players</span> }
    </button>
    @if (!string.IsNullOrEmpty(playersImportLog))
    {
        <pre class="log-output">@playersImportLog</pre>
    }
</div>

@* --- Import Holes --- *@
<div class="migration-section mb-4">
    <h4>4. Import Holes</h4>
    <p>CSV Format: ClubName, CourseName, HoleNumber, Par, StrokeIndex (optional), LengthYards (optional)</p>
    <InputFile OnChange="HandleHolesUpload" accept=".csv" />
    <button class="btn btn-primary mt-2" @onclick="ProcessHoles" disabled="@(holesFile == null || isProcessingHoles || isProcessingGolfClubs || isProcessingGolfCourses || isProcessingPlayers)">
        @if (isProcessingHoles) { <span>Processing...</span> } else { <span>Import Holes</span> }
    </button>
    @if (!string.IsNullOrEmpty(holesImportLog))
    {
        <pre class="log-output">@holesImportLog</pre>
    }
</div>

@* --- Import Rounds --- *@
<div class="migration-section mb-4">
    <h4>5. Import Rounds</h4>
    @* VVV UPDATE THIS LINE VVV *@
    <p>CSV Format: Date (dd/mm/yyyy), PlayerName, ClubName, ActualCourseName, HolesPlayed, StartingHole, RoundType, RoundText (Spreadsheet Key), Notes (optional)</p>
    <InputFile OnChange="HandleRoundsUpload" accept=".csv" />
    <button class="btn btn-primary mt-2" @onclick="ProcessRounds" disabled="@(roundsFile == null || isProcessingRounds || isProcessingGolfClubs || isProcessingGolfCourses || isProcessingPlayers || isProcessingHoles)">
        @if (isProcessingRounds) { <span>Processing...</span> } else { <span>Import Rounds</span> }
    </button>
    @if (!string.IsNullOrEmpty(roundsImportLog))
    {
        <pre class="log-output">@roundsImportLog</pre>
    }
</div>

@* --- Further placeholders for Holes, Rounds, Scores --- *@


<style>
    .migration-section {
        border: 1px solid #ccc;
        padding: 15px;
        margin-bottom: 20px;
        border-radius: 5px;
    }
    .log-output {
        background-color: #f5f5f5;
        border: 1px solid #eee;
        padding: 10px;
        max-height: 200px;
        overflow-y: auto;
        white-space: pre-wrap;
        word-wrap: break-word;
        margin-top:10px;
    }
</style>

@code {
    private IBrowserFile? golfClubsFile;
    private string golfClubsImportLog = string.Empty;
    private bool isProcessingGolfClubs = false;

    public class GolfClubCsvRecord
    {
        public string? Name { get; set; }
        public string? AddressLine1 { get; set; }
        public string? AddressLine2 { get; set; }
        public string? City { get; set; }
        public string? CountyOrRegion { get; set; }
        public string? Postcode { get; set; }
        public string? Country { get; set; }
        public string? Website { get; set; }
    }

    public class GolfCourseCsvRecord
    {
        public string? ClubName { get; set; } // To look up GolfClubId
        public string? CourseName { get; set; }
        public int DefaultPar { get; set; }
        public int NumberOfHoles { get; set; } = 18; // Default if not in CSV
    }

    private IBrowserFile? golfCoursesFile;
    private string golfCoursesImportLog = string.Empty;
    private bool isProcessingGolfCourses = false;

    public class PlayerCsvRecord
    {
        public string? FirstName { get; set; }
        public string? LastName { get; set; }
        public string? Email { get; set; } // Optional
        public double? Handicap { get; set; }
    }

    private IBrowserFile? playersFile;
    private string playersImportLog = string.Empty;
    private bool isProcessingPlayers = false;

    // Add to @code block in DataMigration.razor
    public class HoleCsvRecord
    {
        public string? ClubName { get; set; }     // To help identify the course
        public string? CourseName { get; set; }   // Primary identifier for the course within a club
        public int HoleNumber { get; set; }
        public int Par { get; set; }
        public int? StrokeIndex { get; set; } // Nullable if not always present
        public int? LengthYards { get; set; } // Nullable if not always present
    }

    private IBrowserFile? holesFile;
    private string holesImportLog = string.Empty;
    private bool isProcessingHoles = false;

    // In @code block of DataMigration.razor
    public class RoundCsvRecord
    {
        public string? Date { get; set; }         // Expecting dd/mm/yyyy string
        public string? PlayerName { get; set; }   // Player's full name from CSV for lookup
        public string? ClubName { get; set; }     // Extracted/Separate Club Name
        public string? ActualCourseName { get; set; } // Extracted/Separate Course Name
        public int HolesPlayed { get; set; }
        public int StartingHole { get; set; }
        public string? RoundType { get; set; }    // "Friendly" or "Competitive" from CSV
        public string? RoundText { get; set; }    // Original RoundText from spreadsheet for reference/grouping
    }

    private IBrowserFile? roundsFile; // You should already have this
    private string roundsImportLog = string.Empty; // And this
    private bool isProcessingRounds = false; // And this

    // --- Golf Clubs Import Logic ---
    private void HandleGolfClubsUpload(InputFileChangeEventArgs e)
    {
        golfClubsFile = e.File;
        golfClubsImportLog = $"Selected file: {golfClubsFile.Name}";
    }

    private async Task ProcessGolfClubs()
    {
        if (golfClubsFile == null)
        {
            golfClubsImportLog = "Please select a file first.";
            return;
        }

        isProcessingGolfClubs = true;
        var log = new System.Text.StringBuilder();
        log.AppendLine($"Starting Golf Clubs import from {golfClubsFile.Name}...");
        StateHasChanged(); // Update UI to show processing

        // Use IServiceScopeFactory for long-running operations or when services have a shorter lifetime
        // than the component. For EF Core DbContext, this is good practice.
        await using var scope = ServiceScopeFactory.CreateAsyncScope();
        var golfClubService = scope.ServiceProvider.GetRequiredService<IGolfClubService>();
        var existingClubNames = (await golfClubService.GetAllGolfClubsAsync()).Select(gc => gc.Name.ToLowerInvariant()).ToHashSet();
        int successCount = 0;
        int skippedCount = 0;

        try
        {
            // Max file size (e.g., 5MB). Adjust as needed.
            await using var stream = golfClubsFile.OpenReadStream(maxAllowedSize: 5 * 1024 * 1024);
            using var reader = new StreamReader(stream);
            using var csv = new CsvReader(reader, new CsvConfiguration(CultureInfo.InvariantCulture)
            {
                HasHeaderRecord = true, // Assuming your CSV has a header row
                MissingFieldFound = null, // Handle missing fields gracefully if needed
                HeaderValidated = null, // Handle header validation if needed
            });


            await foreach (var record in csv.GetRecordsAsync<GolfClubCsvRecord>())
            {
                try
                {
                    var clubName = record.Name;
                    if (string.IsNullOrWhiteSpace(clubName))
                    {
                        log.AppendLine("Skipped row: Club Name is missing.");
                        skippedCount++;
                        continue;
                    }

                    if (existingClubNames.Contains(clubName.ToLowerInvariant()))
                    {
                        log.AppendLine($"Skipped: Golf Club '{clubName}' already exists.");
                        skippedCount++;
                        continue;
                    }

                    var newClub = new GolfClub
                    {
                        Name = clubName,
                        AddressLine1 = record.AddressLine1,
                        AddressLine2 = record.AddressLine2,
                        City = record.City,
                        CountyOrRegion = record.CountyOrRegion,
                        Postcode = record.Postcode,
                        Country = record.Country,
                        Website = record.Website
                    };
                    await golfClubService.AddGolfClubAsync(newClub);
                    existingClubNames.Add(newClub.Name.ToLowerInvariant()); // Add to local cache
                    successCount++;
                    log.AppendLine($"Added: {newClub.Name}");
                }
                catch (Exception rowEx)
                {
                    //log.AppendLine($"Error processing row: {rowEx.Message}. Row data: {string.Join(",", csv.Context.Parser.Record ?? Array.Empty<string>())}");
                    log.AppendLine($"Error processing record (Name: {record?.Name ?? "N/A"}): {rowEx.Message}");
                    skippedCount++;
                }
            }
            log.AppendLine($"\nImport complete. Added: {successCount}, Skipped/Errors: {skippedCount}");
        }
        catch (CsvHelperException csvEx) // Specifically catch CsvHelper exceptions for better diagnostics
        {
            log.AppendLine($"\nCSV PARSING ERROR during import: {csvEx.Message}");
            if (csvEx.Context?.Parser != null)
            {
                log.AppendLine($"Error occurred near Row: {csvEx.Context.Parser.Row}, Raw Record: '{csvEx.Context.Parser.RawRecord?.TrimEnd()}'");
            }
        }
        catch (Exception ex) // Catches other exceptions (e.g., DB errors, file stream issues not caught by CsvHelperException)
        {
            log.AppendLine($"\nFATAL ERROR during import: {ex.Message}");
        }
        finally
        {
            golfClubsImportLog = log.ToString();
            isProcessingGolfClubs = false;
            golfClubsFile = null; // Reset file input
            StateHasChanged(); // Update UI
        }
    }
    
    private void HandleGolfCoursesUpload(InputFileChangeEventArgs e)
    {
        golfCoursesFile = e.File;
        golfCoursesImportLog = $"Selected file: {golfCoursesFile.Name}";
    }

    private async Task ProcessGolfCourses()
    {
        if (golfCoursesFile == null)
        {
            golfCoursesImportLog = "Please select a Golf Courses CSV file first.";
            return;
        }

        isProcessingGolfCourses = true;
        var log = new System.Text.StringBuilder();
        log.AppendLine($"Starting Golf Courses import from {golfCoursesFile.Name}...");
        StateHasChanged();

        await using var scope = ServiceScopeFactory.CreateAsyncScope();
        var golfCourseService = scope.ServiceProvider.GetRequiredService<IGolfCourseService>();
        var golfClubService = scope.ServiceProvider.GetRequiredService<IGolfClubService>(); // To look up Club IDs

        // Create a lookup for GolfClubId by ClubName
        var clubNameToIdLookup = (await golfClubService.GetAllGolfClubsAsync())
                                    .ToDictionary(gc => gc.Name.ToLowerInvariant(), gc => gc.GolfClubId);

        var existingCourseNames = (await golfCourseService.GetAllGolfCoursesAsync())
                                     .Select(course => $"{course.GolfClubId}_{course.Name.ToLowerInvariant()}")
                                     .ToHashSet(); // Check for course name uniqueness within a club

        int successCount = 0;
        int skippedCount = 0;

        try
        {
            await using var stream = golfCoursesFile.OpenReadStream(maxAllowedSize: 5 * 1024 * 1024);
            using var reader = new StreamReader(stream);
            using var csv = new CsvReader(reader, new CsvConfiguration(CultureInfo.InvariantCulture)
            {
                HasHeaderRecord = true,
                MissingFieldFound = null,
                HeaderValidated = null,
            });

            await foreach (var record in csv.GetRecordsAsync<GolfCourseCsvRecord>())
            {
                try
                {
                    if (string.IsNullOrWhiteSpace(record.CourseName) || string.IsNullOrWhiteSpace(record.ClubName))
                    {
                        log.AppendLine("Skipped row: Course Name or Club Name is missing.");
                        skippedCount++;
                        continue;
                    }

                    if (!clubNameToIdLookup.TryGetValue(record.ClubName.ToLowerInvariant(), out var golfClubId))
                    {
                        log.AppendLine($"Skipped: Golf Club '{record.ClubName}' not found for course '{record.CourseName}'. Please import clubs first.");
                        skippedCount++;
                        continue;
                    }

                    var uniqueCourseKey = $"{golfClubId}_{record.CourseName.ToLowerInvariant()}";
                    if (existingCourseNames.Contains(uniqueCourseKey))
                    {
                        log.AppendLine($"Skipped: Golf Course '{record.CourseName}' already exists for club '{record.ClubName}'.");
                        skippedCount++;
                        continue;
                    }

                    var newCourse = new GolfCourse
                    {
                        GolfClubId = golfClubId,
                        Name = record.CourseName,
                        DefaultPar = record.DefaultPar,
                        NumberOfHoles = record.NumberOfHoles <= 0 ? 18 : record.NumberOfHoles // Basic validation/default for NumberOfHoles
                    };

                    await golfCourseService.AddGolfCourseAsync(newCourse);
                    existingCourseNames.Add(uniqueCourseKey); // Add to local cache
                    successCount++;
                    log.AppendLine($"Added Course: {newCourse.Name} (Club: {record.ClubName})");
                }
                catch (Exception rowEx)
                {
                    log.AppendLine($"Error processing course record (CourseName: {record?.CourseName ?? "N/A"}, ClubName: {record?.ClubName ?? "N/A"}): {rowEx.Message}");
                    skippedCount++;
                }
            }
            log.AppendLine($"\nGolf Courses import complete. Added: {successCount}, Skipped/Errors: {skippedCount}");
        }
        catch (CsvHelperException csvEx)
        {
            log.AppendLine($"\nCSV PARSING ERROR during Golf Courses import: {csvEx.Message}");
            if (csvEx.Context?.Parser != null)
            {
                log.AppendLine($"Error occurred near Row: {csvEx.Context.Parser.Row}, Raw Record: '{csvEx.Context.Parser.RawRecord?.TrimEnd()}'");
            }
        }
        catch (Exception ex)
        {
            log.AppendLine($"\nFATAL ERROR during Golf Courses import: {ex.Message}");
        }
        finally
        {
            golfCoursesImportLog = log.ToString();
            isProcessingGolfCourses = false;
            golfCoursesFile = null; // Reset file input
            StateHasChanged();
        }
    }


    private void HandlePlayersUpload(InputFileChangeEventArgs e)
    {
        playersFile = e.File;
        playersImportLog = $"Selected file: {playersFile.Name}";
    }

    private async Task ProcessPlayers()
    {
        if (playersFile == null)
        {
            playersImportLog = "Please select a Players CSV file first.";
            return;
        }

        isProcessingPlayers = true;
        var log = new System.Text.StringBuilder();
        log.AppendLine($"Starting Players import from {playersFile.Name}...");
        StateHasChanged();

        await using var scope = ServiceScopeFactory.CreateAsyncScope();
        var playerService = scope.ServiceProvider.GetRequiredService<IPlayerService>();
        //var userManager = scope.ServiceProvider.GetRequiredService<UserManager<IdentityUser>>(); // For ApplicationUser
        var userManager = scope.ServiceProvider.GetRequiredService<UserManager<ApplicationUser>>(); // Changed to ApplicationUser

        // Cache existing players to help avoid duplicates
        // For registered players, check by ApplicationUserId
        // For managed players, check by FirstName + LastName (case-insensitive)
        var existingRegisteredPlayerUserIds = (await playerService.GetAllPlayersAsync())
                                            .Where(p => !string.IsNullOrEmpty(p.ApplicationUserId))
                                            .Select(p => p.ApplicationUserId)
                                            .ToHashSet();
        var existingManagedPlayerNames = (await playerService.GetAllPlayersAsync())
                                        .Where(p => string.IsNullOrEmpty(p.ApplicationUserId))
                                        .Select(p => $"{p.FirstName?.ToLowerInvariant()}_{p.LastName?.ToLowerInvariant()}")
                                        .ToHashSet();
        int successCount = 0;
        int skippedCount = 0;
        int usersCreatedCount = 0;

        try
        {
            await using var stream = playersFile.OpenReadStream(maxAllowedSize: 5 * 1024 * 1024);
            using var reader = new StreamReader(stream);
            using var csv = new CsvReader(reader, new CsvConfiguration(CultureInfo.InvariantCulture) { HasHeaderRecord = true });

            await foreach (var record in csv.GetRecordsAsync<PlayerCsvRecord>())
            {
                try
                {
                    if (string.IsNullOrWhiteSpace(record.FirstName) || string.IsNullOrWhiteSpace(record.LastName))
                    {
                        log.AppendLine("Skipped row: FirstName or LastName is missing.");
                        skippedCount++;
                        continue;
                    }

                    string? appUserId = null;
                    bool isRegisteredPlayer = !string.IsNullOrWhiteSpace(record.Email);

                    if (isRegisteredPlayer)
                    {
                        var user = await userManager.FindByEmailAsync(record.Email!);
                        if (user == null)
                        {
                            // Create new ApplicationUser
                            //user = new IdentityUser { UserName = record.Email, Email = record.Email, EmailConfirmed = true }; // Auto-confirm for simplicity
                            user = new ApplicationUser { UserName = record.Email, Email = record.Email, EmailConfirmed = true }; // Changed to ApplicationUser, Auto-confirm for simplicity
                            var createUserResult = await userManager.CreateAsync(user, $"DefaultP@ssw0rd{DateTime.Now.Ticks}"); // Generate a complex default password
                            if (!createUserResult.Succeeded)
                            {
                                log.AppendLine($"Failed to create user for {record.Email}: {string.Join(", ", createUserResult.Errors.Select(e => e.Description))}");
                                skippedCount++;
                                continue;
                            }
                            // Optionally add to "User" role
                            await userManager.AddToRoleAsync(user, "User");
                            log.AppendLine($"Created new system user for email: {record.Email}");
                            usersCreatedCount++;
                        }
                        appUserId = user.Id;

                        if (existingRegisteredPlayerUserIds.Contains(appUserId))
                        {
                            log.AppendLine($"Skipped: Player profile for user {record.Email} already exists.");
                            skippedCount++;
                            continue;
                        }
                    }
                    else // Managed player
                    {
                        var managedPlayerKey = $"{record.FirstName.ToLowerInvariant()}_{record.LastName.ToLowerInvariant()}";
                        if (existingManagedPlayerNames.Contains(managedPlayerKey))
                        {
                            log.AppendLine($"Skipped: Managed player '{record.FirstName} {record.LastName}' already exists.");
                            skippedCount++;
                            continue;
                        }
                    }

                    var newPlayer = new Player
                    {
                        FirstName = record.FirstName,
                        LastName = record.LastName,
                        // // Store email on Player model if you added it, useful even for managed players
                        Handicap = record.Handicap,
                        ApplicationUserId = appUserId
                    };

                    await playerService.AddPlayerAsync(newPlayer);

                    if (isRegisteredPlayer && appUserId != null)
                    {
                        existingRegisteredPlayerUserIds.Add(appUserId);
                    }
                    else
                    {
                        existingManagedPlayerNames.Add($"{record.FirstName.ToLowerInvariant()}_{record.LastName.ToLowerInvariant()}");
                    }
                    successCount++;
                    log.AppendLine($"Added Player: {newPlayer.FirstName} {newPlayer.LastName} {(isRegisteredPlayer ? $"(User: {record.Email})" : "(Managed)")}");
                }
                catch (Exception rowEx)
                {
                    log.AppendLine($"Error processing player record (Name: {record?.FirstName} {record?.LastName}): {rowEx.Message}");
                    skippedCount++;
                }
            }
            log.AppendLine($"\nPlayers import complete. Added: {successCount}, Skipped/Errors: {skippedCount}, New System Users Created: {usersCreatedCount}");
        }
        catch (CsvHelperException csvEx)
        {
            log.AppendLine($"\nCSV PARSING ERROR during Players import: {csvEx.Message}");
            if (csvEx.Context?.Parser != null) { log.AppendLine($"Error occurred near Row: {csvEx.Context.Parser.Row}, Raw Record: '{csvEx.Context.Parser.RawRecord?.TrimEnd()}'"); }
        }
        catch (Exception ex)
        {
            log.AppendLine($"\nFATAL ERROR during Players import: {ex.Message}");
        }
        finally
        {
            playersImportLog = log.ToString();
            isProcessingPlayers = false;
            playersFile = null; // Reset file input
            StateHasChanged();
        }
    }

    private void HandleHolesUpload(InputFileChangeEventArgs e)
    {
        holesFile = e.File;
        holesImportLog = $"Selected file: {holesFile.Name}";
    }

    private async Task ProcessHoles()
    {
        if (holesFile == null)
        {
            holesImportLog = "Please select a Holes CSV file first.";
            return;
        }

        isProcessingHoles = true;
        var log = new System.Text.StringBuilder();
        log.AppendLine($"Starting Holes import from {holesFile.Name}...");
        StateHasChanged();

        await using var scope = ServiceScopeFactory.CreateAsyncScope();
        var holeService = scope.ServiceProvider.GetRequiredService<IHoleService>();
        var courseService = scope.ServiceProvider.GetRequiredService<IGolfCourseService>();

        // Create a lookup for GolfCourseId by a composite key (e.g., "clubname_coursename")
        // Ensure GolfClub is included to get ClubName if your GolfCourse model doesn't store it directly
        var courses = await courseService.GetAllGolfCoursesAsync(); // Assumes this includes GolfClub
        var courseLookup = courses.ToDictionary(
            // Ensure GolfClub is not null; might need to adjust if GolfClub can be null or if Name is nullable
            // This key assumes that course names are unique within a club.
            course => $"{(course.GolfClub?.Name ?? "UNKNOWN_CLUB").ToLowerInvariant()}_{course.Name.ToLowerInvariant()}",
            course => course.GolfCourseId
        );

        // Cache existing holes to prevent duplicates for a course (HoleNumber should be unique per course)
        // Key: "CourseId_HoleNumber"
        var existingHolesLookup = new HashSet<string>();
        foreach(var course in courses)
        {
            var holesForCourse = await holeService.GetHolesForCourseAsync(course.GolfCourseId);
            foreach(var hole in holesForCourse)
            {
                existingHolesLookup.Add($"{hole.GolfCourseId}_{hole.HoleNumber}");
            }
        }


        int successCount = 0;
        int skippedCount = 0;

        try
        {
            await using var stream = holesFile.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024); // Increased size a bit for hole data
            using var reader = new StreamReader(stream);
            using var csv = new CsvReader(reader, new CsvConfiguration(CultureInfo.InvariantCulture)
            {
                HasHeaderRecord = true,
                MissingFieldFound = null,
                HeaderValidated = null,
            });

            await foreach (var record in csv.GetRecordsAsync<HoleCsvRecord>())
            {
                try
                {
                    if (string.IsNullOrWhiteSpace(record.CourseName) || string.IsNullOrWhiteSpace(record.ClubName) || record.HoleNumber <= 0 || record.Par <= 0)
                    {
                        log.AppendLine($"Skipped row: CourseName, ClubName, valid HoleNumber, or Par is missing. Club: '{record.ClubName}', Course: '{record.CourseName}', Hole: {record.HoleNumber}");
                        skippedCount++;
                        continue;
                    }

                    var courseLookupKey = $"{record.ClubName.ToLowerInvariant()}_{record.CourseName.ToLowerInvariant()}";
                    if (!courseLookup.TryGetValue(courseLookupKey, out var golfCourseId))
                    {
                        log.AppendLine($"Skipped Hole {record.HoleNumber} for '{record.CourseName}' (Club: {record.ClubName}): Golf Course not found. Please import courses first.");
                        skippedCount++;
                        continue;
                    }

                    var holeLookupKey = $"{golfCourseId}_{record.HoleNumber}";
                    if (existingHolesLookup.Contains(holeLookupKey))
                    {
                        log.AppendLine($"Skipped: Hole number {record.HoleNumber} already exists for course '{record.CourseName}' (Club: {record.ClubName}).");
                        skippedCount++;
                        continue;
                    }

                    var newHole = new Hole
                    {
                        GolfCourseId = golfCourseId,
                        HoleNumber = record.HoleNumber,
                        Par = record.Par,
                        StrokeIndex = record.StrokeIndex,
                        LengthYards = record.LengthYards
                    };

                    await holeService.AddHoleAsync(newHole);
                    existingHolesLookup.Add(holeLookupKey); // Add to local cache
                    successCount++;
                    log.AppendLine($"Added: Hole {newHole.HoleNumber} for {record.CourseName} (Club: {record.ClubName})");
                }
                catch (Exception rowEx)
                {
                    log.AppendLine($"Error processing hole record (Course: {record?.CourseName ?? "N/A"}, Hole: {record?.HoleNumber}): {rowEx.Message}");
                    skippedCount++;
                }
            }
            log.AppendLine($"\nHoles import complete. Added: {successCount}, Skipped/Errors: {skippedCount}");
        }
        catch (CsvHelperException csvEx)
        {
            log.AppendLine($"\nCSV PARSING ERROR during Holes import: {csvEx.Message}");
            if (csvEx.Context?.Parser != null)
            {
                log.AppendLine($"Error occurred near Row: {csvEx.Context.Parser.Row}, Raw Record: '{csvEx.Context.Parser.RawRecord?.TrimEnd()}'");
            }
        }
        catch (Exception ex)
        {
            log.AppendLine($"\nFATAL ERROR during Holes import: {ex.Message}");
        }
        finally
        {
            holesImportLog = log.ToString();
            isProcessingHoles = false;
            holesFile = null; // Reset file input
            StateHasChanged();
        }
    }

    private void HandleRoundsUpload(InputFileChangeEventArgs e)
    {
        roundsFile = e.File;
        roundsImportLog = $"Selected file: {roundsFile.Name}";
    }

    private async Task ProcessRounds()
    {
        if (roundsFile == null)
        {
            roundsImportLog = "Please select a Rounds CSV file first.";
            return;
        }

        isProcessingRounds = true;
        var log = new System.Text.StringBuilder();
        log.AppendLine($"Starting Rounds import from {roundsFile.Name}...");
        StateHasChanged(); // Update UI to show processing

        await using var scope = ServiceScopeFactory.CreateAsyncScope();
        var roundService = scope.ServiceProvider.GetRequiredService<IRoundService>();
        var courseService = scope.ServiceProvider.GetRequiredService<IGolfCourseService>();
        var playerService = scope.ServiceProvider.GetRequiredService<IPlayerService>();
        var dbContext = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();

        // --- Lookups ---
        var coursesFromDb = await courseService.GetAllGolfCoursesAsync(); // Assumes this includes GolfClub
        var courseLookup = coursesFromDb.ToDictionary(
            course => $"{(course.GolfClub?.Name ?? "UNKNOWN_CLUB").ToLowerInvariant()}_{(course.Name ?? "UNKNOWN_COURSE").ToLowerInvariant()}",
            course => course.GolfCourseId
        );

        var playersFromDb = await playerService.GetAllPlayersAsync();
        // IMPORTANT: Adjust this playerLookup key based on how PlayerName in CSV matches your Player data.
        // This assumes PlayerName in CSV is "FirstName LastName".
        var playerLookup = playersFromDb.ToDictionary(
            player => $"{player.FirstName?.ToLowerInvariant()} {player.LastName?.ToLowerInvariant()}".Trim(),
            player => player.PlayerId
        );
        // If PlayerName in CSV is just FirstName (and LastName was empty/default during player import):
        // var playerLookup = playersFromDb.ToDictionary(
        //     player => player.FirstName.ToLowerInvariant(),
        //     player => player.PlayerId
        // );

        // Key: The grouping key from CSV. Value: The newly created database RoundID
        var processedSharedRoundsLookup = new Dictionary<string, int>();
        int successRoundPlayerCount = 0;
        int newSharedRoundsCreatedCount = 0;
        int skippedRowCount = 0;

        try
        {
            var csvConfig = new CsvConfiguration(CultureInfo.InvariantCulture)
            {
                HasHeaderRecord = true,
                MissingFieldFound = null,
                HeaderValidated = null,
                PrepareHeaderForMatch = args => args.Header.ToLower().Replace(" ", "").Replace("_", ""),
            };

            List<RoundCsvRecord> allCsvRows = new List<RoundCsvRecord>();
            await using (var stream = roundsFile.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024))
            using (var reader = new StreamReader(stream))
            using (var csv = new CsvReader(reader, csvConfig))
            {
                // Asynchronously iterate and add to list
                await foreach (var record in csv.GetRecordsAsync<RoundCsvRecord>()) // <--- Use GetRecordsAsync
                {
                    allCsvRows.Add(record);
                }
            }

            var groupedBySharedRound = allCsvRows.GroupBy(row =>
            {
                var dateParsed = DateTime.TryParseExact(row.Date, "dd/MM/yyyy", CultureInfo.InvariantCulture, DateTimeStyles.None, out var dt) ? dt.ToShortDateString() : row.Date;
                // Grouping key based on distinct fields from CSV
                return $"{row.ClubName?.ToLowerInvariant()}_{row.ActualCourseName?.ToLowerInvariant()}_{dateParsed}_{row.RoundType?.ToLowerInvariant()}_{row.StartingHole}_{row.HolesPlayed}";
            });

            foreach (var group in groupedBySharedRound)
            {
                var firstRecordInGroup = group.First();
                string sharedRoundLogKey = $"Club: '{firstRecordInGroup.ClubName}', Course: '{firstRecordInGroup.ActualCourseName}', Date: {firstRecordInGroup.Date}, Type: {firstRecordInGroup.RoundType}, StartHole: {firstRecordInGroup.StartingHole}, HolesPlayed: {firstRecordInGroup.HolesPlayed}";

                int currentDbRoundId;
                string groupKeyForDbLookup = group.Key;

                if (processedSharedRoundsLookup.TryGetValue(groupKeyForDbLookup, out var existingDbRoundIdInSession))
                {
                    currentDbRoundId = existingDbRoundIdInSession;
                }
                else
                {
                    // This 'else' block is for when the shared round hasn't been processed in *this current import session*.
                    // We still need to check if an identical round exists in the database from a *previous* import run.

                    string courseLookupKey = $"{(firstRecordInGroup.ClubName ?? "UNKNOWN_CLUB").ToLowerInvariant()}_{(firstRecordInGroup.ActualCourseName ?? "UNKNOWN_COURSE").ToLowerInvariant()}";
                    if (!courseLookup.TryGetValue(courseLookupKey, out var golfCourseId))
                    {
                        log.AppendLine($"Skipped group ({sharedRoundLogKey}): Golf Course combination not found. Club: '{firstRecordInGroup.ClubName}', Course: '{firstRecordInGroup.ActualCourseName}'.");
                        skippedRowCount += group.Count();
                        continue;
                    }

                    if (!DateTime.TryParseExact(firstRecordInGroup.Date, "dd/MM/yyyy", CultureInfo.InvariantCulture, DateTimeStyles.None, out var roundDate))
                    {
                        log.AppendLine($"Skipped group ({sharedRoundLogKey}): Invalid date format '{firstRecordInGroup.Date}'. Expected dd/mm/yyyy.");
                        skippedRowCount += group.Count();
                        continue;
                    }

                    if (!Enum.TryParse<RoundTypeOption>(firstRecordInGroup.RoundType, true, out var roundTypeEnum))
                    {
                        log.AppendLine($"Skipped group ({sharedRoundLogKey}): Invalid RoundType '{firstRecordInGroup.RoundType}'. Cannot parse to enum. CSV Value: '{firstRecordInGroup.RoundType}'");
                        skippedRowCount += group.Count();
                        continue;
                    }

                    // Check if an identical Round already exists in the DB from a previous import run
                    var identicalExistingRoundInDb = await dbContext.Rounds
                        .FirstOrDefaultAsync(r => r.GolfCourseId == golfCourseId &&
                                             r.DatePlayed == roundDate &&
                                             r.StartingHole == firstRecordInGroup.StartingHole &&
                                             r.HolesPlayed == firstRecordInGroup.HolesPlayed &&
                                             r.RoundType == roundTypeEnum); // Match enum directly

                    if (identicalExistingRoundInDb != null)
                    {
                        currentDbRoundId = identicalExistingRoundInDb.RoundId;
                        log.AppendLine($"Found existing shared Round ID in DB: {currentDbRoundId} for {sharedRoundLogKey}");
                        processedSharedRoundsLookup.TryAdd(groupKeyForDbLookup, currentDbRoundId); // Add to session lookup
                    }
                    else
                    {
                        var newDbRound = new Round
                        {
                            GolfCourseId = golfCourseId,
                            DatePlayed = roundDate,
                            StartingHole = firstRecordInGroup.StartingHole,
                            HolesPlayed = firstRecordInGroup.HolesPlayed,
                            RoundType = roundTypeEnum, // Assign the enum directly
                            Notes = null
                        };
                        dbContext.Rounds.Add(newDbRound);
                        await dbContext.SaveChangesAsync(); // Save to get newDbRound.RoundId
                        currentDbRoundId = newDbRound.RoundId;
                        processedSharedRoundsLookup.Add(groupKeyForDbLookup, currentDbRoundId);
                        newSharedRoundsCreatedCount++;
                        log.AppendLine($"Created shared Round ID: {currentDbRoundId} for {sharedRoundLogKey}");
                    }
                } // End of creating/finding shared Round (currentDbRoundId is set)

                // 2. Add players to this Round via RoundPlayer entries for the current group
                foreach (var playerRecordInGroup in group)
                {
                    string playerFullNameCsv = playerRecordInGroup.PlayerName ?? "";
                    // Ensure the playerLookup key matches how PlayerName is formatted in CSV and how keys were generated for playerLookup
                    if (!playerLookup.TryGetValue(playerFullNameCsv.ToLowerInvariant().Trim(), out var playerId))
                    {
                        log.AppendLine($"Skipped player '{playerFullNameCsv}' for round ID {currentDbRoundId} ({sharedRoundLogKey}): Player not found in lookup.");
                        skippedRowCount++; // This specific player in this group is skipped
                        continue;
                    }

                    // Check if this player is already added to this specific round (idempotency for RoundPlayer)
                    bool alreadyLinked = await dbContext.RoundPlayers
                                             .AnyAsync(rp => rp.RoundId == currentDbRoundId && rp.PlayerId == playerId);
                    if (alreadyLinked)
                    {
                        log.AppendLine($"Player '{playerFullNameCsv}' already linked to round ID {currentDbRoundId}. Skipping duplicate RoundPlayer entry.");
                        continue;
                    }

                    var roundPlayerEntry = new RoundPlayer
                    {
                        RoundId = currentDbRoundId,
                        PlayerId = playerId
                        // ShotScore and ParScore are not set here as they will be calculated
                    };
                    dbContext.RoundPlayers.Add(roundPlayerEntry);
                    successRoundPlayerCount++; // Counts individual player links to rounds
                    log.AppendLine($"Linked Player '{playerFullNameCsv}' to Round ID {currentDbRoundId}");
                }
                await dbContext.SaveChangesAsync(); // Save all RoundPlayer entries for this group
            } // End foreach group

            log.AppendLine($"\nRounds import complete. New Shared Rounds Created: {newSharedRoundsCreatedCount}, Player Links to Rounds Processed: {successRoundPlayerCount}, Skipped CSV Rows/Entries: {skippedRowCount}");
        }
        catch (CsvHelperException csvEx)
        {
            log.AppendLine($"\nCSV PARSING ERROR during Rounds import: {csvEx.Message}");
            if (csvEx.Context?.Parser != null)
            {
                log.AppendLine($"Error occurred near Row: {csvEx.Context.Parser.Row}, Raw Record: '{csvEx.Context.Parser.RawRecord?.TrimEnd()}'");
            }
        }
        catch (Exception ex)
        {
            log.AppendLine($"\nFATAL ERROR during Rounds import: {ex.Message} \nStackTrace: {ex.StackTrace}");
        }
        finally
        {
            roundsImportLog = log.ToString();
            isProcessingRounds = false;
            roundsFile = null; // Reset file input
            StateHasChanged();
        }
    } // End ProcessRounds

    @* private async Task ProcessRounds()
    {
        if (roundsFile == null)
        {
            roundsImportLog = "Please select a Rounds CSV file first.";
            return;
        }

        isProcessingRounds = true;
        var log = new System.Text.StringBuilder();
        log.AppendLine($"Starting Rounds import from {roundsFile.Name}...");
        StateHasChanged();

        await using var scope = ServiceScopeFactory.CreateAsyncScope();
        var roundService = scope.ServiceProvider.GetRequiredService<IRoundService>();
        var courseService = scope.ServiceProvider.GetRequiredService<IGolfCourseService>();
        var playerService = scope.ServiceProvider.GetRequiredService<IPlayerService>();
        var dbContext = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>(); // For more complex lookups if needed

        // --- Lookups ---
        var coursesFromDb = await courseService.GetAllGolfCoursesAsync(); // Assumes this includes GolfClub
        var courseLookup = coursesFromDb.ToDictionary(
            // Key: "clubname_coursename" (lowercase). Ensure your CSV 'Course' field can be parsed to this.
            // For reliable parsing, you might need a more robust way to split "Club Name - CourseName" from CSV.
            // For now, we'll assume CSV 'Course' field is just "CourseName" and 'ClubName' is separate if available in DTO.
            // Let's refine this based on RoundCsvRecord:
            // Assuming RoundCsvRecord has separate ClubName and CourseName, or Course is "Club - Course"
            course => $"{(course.GolfClub?.Name ?? "UNKNOWN_CLUB").ToLowerInvariant()}_{course.Name.ToLowerInvariant()}",
            course => course.GolfCourseId
        );

        var playersFromDb = await playerService.GetAllPlayersAsync();
        var playerLookup = playersFromDb.ToDictionary(
            player => $"{player.FirstName.ToLowerInvariant()} {player.LastName.ToLowerInvariant()}", // Key: "firstname lastname"
            player => player.PlayerId
        );

        // --- Temporary storage for this import session ---
        // Key: The grouping key from CSV (e.g., RoundText, or a composite of Date, CourseID, RoundType, StartHole, HolesPlayed)
        // Value: The newly created database RoundID
        var processedSharedRoundsLookup = new Dictionary<string, int>();

        int successRoundPlayerCount = 0;
        int newSharedRoundsCreatedCount = 0;
        int skippedRowCount = 0;

        try
        {
            var csvConfig = new CsvConfiguration(CultureInfo.InvariantCulture)
            {
                HasHeaderRecord = true,
                MissingFieldFound = null,
                HeaderValidated = null,
                PrepareHeaderForMatch = args => args.Header.ToLower().Replace(" ", ""), // More resilient header matching
            };

            // It might be easier to read all records into memory first to group them
            List<RoundCsvRecord> allCsvRows;
            await using (var stream = roundsFile.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024))
            using (var reader = new StreamReader(stream))
            using (var csv = new CsvReader(reader, csvConfig))
            {
                allCsvRows = csv.GetRecords<RoundCsvRecord>().ToList();
            }

            // Group CSV rows by a unique identifier for the shared round.
            // `RoundText` seems like a good candidate if it's consistent for all players in a conceptual round.
            // Alternatively, group by Date, Course (parsed), RoundType, StartingHole, HolesPlayed.
            // Let's use RoundText for grouping, assuming its format is consistent enough for this.
            // The part of RoundText that identifies the SHARED round is:
            // Course & " - " & RoundType & " - " & Date (DD/MM/YYYY)
            // We'll also need StartingHole and HolesPlayed if they vary and define the round boundary.

            var groupedBySharedRound = allCsvRows.GroupBy(row =>
            {
                var dateParsed = DateTime.TryParseExact(row.Date, "dd/MM/yyyy", CultureInfo.InvariantCulture, DateTimeStyles.None, out var dt) ? dt.ToShortDateString() : row.Date;
                // Grouping key based on discrete fields
                return $"{row.ClubName?.ToLowerInvariant()}_{row.ActualCourseName?.ToLowerInvariant()}_{dateParsed}_{row.RoundType?.ToLowerInvariant()}_{row.StartingHole}_{row.HolesPlayed}";
            });


            foreach (var group in groupedBySharedRound)
            {
                var firstRecordInGroup = group.First(); // Use the first record for shared round details
                string sharedRoundLogKey = $"Course: {firstRecordInGroup.Course}, Date: {firstRecordInGroup.Date}, Type: {firstRecordInGroup.RoundType}, Start: {firstRecordInGroup.StartingHole}, NumHoles: {firstRecordInGroup.HolesPlayed}";

                // 1. Find or Create the main Round entity
                int currentDbRoundId;
                string groupKeyForDbLookup = group.Key; // The key we used for grouping

                if (processedSharedRoundsLookup.TryGetValue(groupKeyForDbLookup, out var existingDbRoundId))
                {
                    currentDbRoundId = existingDbRoundId;
                }
                else
                {
                    // Attempt to parse ClubName and CourseName from firstRecordInGroup.Course if necessary
                    // For simplicity, assume firstRecordInGroup.ClubName and firstRecordInGroup.CourseName are distinct in DTO
                    string courseLookupKey = $"{(firstRecordInGroup.ClubName ?? "UNKNOWN_CLUB").ToLowerInvariant()}_{(firstRecordInGroup.CourseName ?? "UNKNOWN_COURSE").ToLowerInvariant()}";

                    if (!courseLookup.TryGetValue(courseLookupKey, out var golfCourseId))
                    {
                        log.AppendLine($"Skipped group ({sharedRoundLogKey}): Golf Course '{firstRecordInGroup.ClubName} - {firstRecordInGroup.CourseName}' not found.");
                        skippedRowCount += group.Count();
                        continue;
                    }

                    if (!DateTime.TryParseExact(firstRecordInGroup.Date, "dd/MM/yyyy", CultureInfo.InvariantCulture, DateTimeStyles.None, out var roundDate))
                    {
                        log.AppendLine($"Skipped group ({sharedRoundLogKey}): Invalid date format '{firstRecordInGroup.Date}'. Expected dd/mm/yyyy.");
                        skippedRowCount += group.Count();
                        continue;
                    }

                    RoundTypeOption roundTypeEnum;
                    if (!Enum.TryParse<RoundTypeOption>(firstRecordInGroup.RoundType, true, out roundTypeEnum))
                    {
                        log.AppendLine($"Skipped group ({sharedRoundLogKey}): Invalid RoundType '{firstRecordInGroup.RoundType}'. Defaulting to Friendly or skipping.");
                        // Decide to default or skip. Let's try to default for now.
                        roundTypeEnum = RoundTypeOption.Friendly; // Or skip if strictness is required
                    }

                    var newDbRound = new Round
                    {
                        GolfCourseId = golfCourseId,
                        DatePlayed = roundDate,
                        StartingHole = firstRecordInGroup.StartingHole,
                        HolesPlayed = firstRecordInGroup.HolesPlayed,
                        RoundType = roundTypeEnum.ToString(), // Storing as string as per current Round model
                        // Notes can be tricky if they differ per player row for the same conceptual round.
                        // Take notes from the first player or concatenate, or decide on a rule.
                        Notes = firstRecordInGroup.Notes
                    };

                    // TODO: Check if an identical Round (same course, date, type, holes) already exists in DB to prevent duplicates from re-runs.
                    // This requires a query to dbContext.Rounds.
                    // For now, AddRoundAsync doesn't have this deep duplicate check.

                    var addedDbRound = await roundService.AddRoundAsync(newDbRound, new List<int>()); // Add round shell without players initially
                    currentDbRoundId = addedDbRound.RoundId;
                    processedSharedRoundsLookup.Add(groupKeyForDbLookup, currentDbRoundId);
                    newSharedRoundsCreatedCount++;
                    log.AppendLine($"Created shared Round ID: {currentDbRoundId} for {sharedRoundLogKey}");
                }

                // 2. Add players to this Round via RoundPlayer entries
                foreach (var playerRecordInGroup in group)
                {
                    string playerFullNameCsv = playerRecordInGroup.Player ?? "";
                    if (!playerLookup.TryGetValue(playerFullNameCsv.ToLowerInvariant(), out var playerId))
                    {
                        log.AppendLine($"Skipped player '{playerFullNameCsv}' for round ID {currentDbRoundId}: Player not found.");
                        skippedRowCount++; // This specific player in this group is skipped
                        continue;
                    }

                    // Check if this player is already added to this specific round (idempotency for RoundPlayer)
                    bool alreadyExists = await dbContext.RoundPlayers
                                              .AnyAsync(rp => rp.RoundId == currentDbRoundId && rp.PlayerId == playerId);
                    if (alreadyExists)
                    {
                        log.AppendLine($"Player '{playerFullNameCsv}' already in round ID {currentDbRoundId}. Skipping RoundPlayer entry.");
                        // Don't increment skippedRowCount if it's just a duplicate we're avoiding
                        continue;
                    }

                    var roundPlayerEntry = new RoundPlayer
                    {
                        RoundId = currentDbRoundId,
                        PlayerId = playerId
                        // ShotScore and ParScore are not set here as they will be calculated from hole-by-hole scores
                    };
                    dbContext.RoundPlayers.Add(roundPlayerEntry);
                    successRoundPlayerCount++;
                    log.AppendLine($"Linked Player '{playerFullNameCsv}' to Round ID {currentDbRoundId}");
                }
                await dbContext.SaveChangesAsync(); // Save all RoundPlayer entries for this group
            }
            log.AppendLine($"\nRounds import complete. New Shared Rounds Created: {newSharedRoundsCreatedCount}, Player Links to Rounds Added/Processed: {successRoundPlayerCount}, Skipped CSV Rows: {skippedRowCount}");
        }
        catch (CsvHelperException csvEx)
        {
            log.AppendLine($"\nCSV PARSING ERROR during Rounds import: {csvEx.Message}");
            if (csvEx.Context?.Parser != null) { log.AppendLine($"Error occurred near Row: {csvEx.Context.Parser.Row}, Raw Record: '{csvEx.Context.Parser.RawRecord?.TrimEnd()}'"); }
        }
        catch (Exception ex)
        {
            log.AppendLine($"\nFATAL ERROR during Rounds import: {ex.Message}");
        }
        finally
        {
            roundsImportLog = log.ToString();
            isProcessingRounds = false;
            roundsFile = null;
            StateHasChanged();
        }
    } *@


    // --- Placeholder for other entity import logic (GolfCourses, Players, etc.) ---
    // private IBrowserFile? golfCoursesFile;
    // private string golfCoursesImportLog = string.Empty;
    // private bool isProcessingGolfCourses = false;
    // ... and so on for other types
}